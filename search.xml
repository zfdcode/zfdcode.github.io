<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Note]]></title>
    <url>%2F2018%2F07%2F30%2FLeetCode_Note%2F</url>
    <content type="text"><![CDATA[LeetCode的刷题笔记 刷题，若干笔记要点：永远考虑时间复杂度与存储空间需求 Array and StringIntroduction to ArrayFind Pivot IndexGiven an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. 12345678910111213def pivotIndex( nums): """ :type nums: List[int] :rtype: int 历遍list找pivot """ sum_nums=sum(nums) left_sum=0 for i,num in enumerate(nums): if left_sum == (sum_nums - left_sum - num): return i left_sum+=num return -1 Largest Number At Least Twice of OthersIn a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. 123456789101112def dominantIndex( nums): """ :type nums: List[int] :rtype: int 对比sorted list最大和第二大元素，时间复杂度依据sort算法而定 """ if len(nums)==1: return 0 indexes = range(len(nums)) nums, indexes = zip(*sorted(zip(nums, indexes),reverse=True)) return indexes[0] if nums[0]&gt;=2*nums[1] else -1 Plus OneGiven a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. 12345678910111213141516def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] 从list尾部开始加1，如果大于十进一位 """ add_one_index=0 digits=digits[::-1] while add_one_index&lt;len(digits) and digits[add_one_index]==9: digits[add_one_index]=0 add_one_index+=1 if add_one_index==len(digits): digits.append(0) digits[add_one_index]+=1 return digits[::-1] Introduction to 2D ArrayDiagonal TraverseGiven a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. 1234567891011121314151617181920212223242526272829303132333435def findDiagonalOrder( matrix): """ :type matrix: List[List[int]] :rtype: List[int] 根据方向选择位置变化 """ temp_list=[] if not matrix: return temp_list r,c=0,0 m,n=len(matrix),len(matrix[0]) upper_right=True while len(temp_list)&lt;m*n: temp_list.append(matrix[r][c]) if upper_right: if r==0 or c==n-1: upper_right=False if c!=n-1: c+=1 else: r+=1 else: r-=1 c+=1 else: if r==m-1 or c==0: upper_right=True if r!=m-1: r+=1 else: c+=1 else: r+=1 c-=1 return temp_list Spiral MatrixGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 12345678910111213141516171819202122def spiralOrder( matrix): """ :type matrix: List[List[int]] :rtype: List[int] 不断将最外圈元素依次加入list。另一种更python的做法：向左旋转matrix，将第一排元素加入list """ if not matrix: return matrix ans = [] m, n = len(matrix), len(matrix[0]) u, d, l, r = 0, m - 1, 0, n - 1 while l &lt; r and u &lt; d: ans.extend([matrix[u][j] for j in range(l, r)]) ans.extend([matrix[i][r] for i in range(u, d)]) ans.extend([matrix[d][j] for j in range(r, l, -1)]) ans.extend([matrix[i][l] for i in range(d, u, -1)]) u, d, l, r = u + 1, d - 1, l + 1, r - 1 if l == r: ans.extend([matrix[i][r] for i in range(u, d + 1)]) elif u == d: ans.extend([matrix[u][j] for j in range(l, r + 1)]) return ans Pascal’s TriangleGiven a non-negative integer numRows, generate the first numRows of Pascal’s triangle. 1234567891011121314151617181920def generate( numRows): """ :type numRows: int :rtype: List[List[int]] 迭代计算，多次计算将较小数缓存可以提高运行速度。 """ if numRows&lt;1: return [] elif numRows==1: return [[1]] elif numRows==2: return [[1],[1,1]] else: matrix=self.generate(numRows-1) temp_list=[1] for i in range(len(matrix[-1])-1): temp_list.append(matrix[-1][i]+matrix[-1][i+1]) temp_list.append(1) matrix.append(temp_list) return matrix]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身笔记]]></title>
    <url>%2F2018%2F02%2F15%2FExercise%2F</url>
    <content type="text"><![CDATA[To be a better man. 饮食训后饮食 蛋白质20g 糖/碳水体重*0.5g 肌酸 锌热量不计入当天总热量 减脂增肌饮食热量缺口300-500大卡，最大化增肌300大卡目前训练日以1900大卡为准 碳水化物50% 240g碳水化物，早40g，中150g，晚50g，下午加餐晚上视情况减少 蛋白质30% 140g蛋白质，早起、训练前后各20g乳清蛋白，午餐后、睡前各25g乳酪蛋白，一日200g肉即40g蛋白 脂肪20% 45g 100g瘦肉约含蛋白质20g以及脂肪2-10克，瘦肉每100g粗略可算热量150大卡 健身知识身体如何燃烧脂肪$\beta$-氧化就是当脂肪酸分解成线粒体，最终变成作为能量来使用的辅酶A。脂肪酸的运输：脂肪酸分子来自可食用的脂肪，脂肪酸会在胞质溶胶（细胞中的水分）中与辅酶A结合，产生脂肪酸乙醯辅酶A。脂肪酸乙醯辅酶A会被肉碱改变。肉碱会与脂肪酸产生反应，结合之后在带到线粒体内膜中，产生能量，经由细胞中的胞质溶胶再到线粒体内膜中，开始作为能量使用。恒速有氧运动消耗的脂肪：一个脂肪酸分子的氧化作用和脂肪结合会产生超过100个三磷酸腺苷分子，而和葡萄糖或血糖分子结合只会产生36个。三磷酸腺苷分子是身体能量的来源。 热身热身的作用在于预防肌肉受伤，提高肌肉温度以及活动范围，从而使动作更加效率安全。 动态伸展健身前的10大動態伸展動作 尺蠖*10 90/90伸展5\2 十字架翻轉5\2 撐體翻身5\2 三方向的弓步伸展(前侧前45°侧方)53\2 腿後腱弓步伸展5\2 腿後腱直腿伸展5\2 開罐器10\2 肩膀擺盪10\2 腳踝伸展10\2 深蹲前热身深蹲前的暖身流程 分开动作 抓住脚尖蹲下*6 手放在头后方向后展开*6 一手抓另一边脚，另一只手向后上方旋转*6 双手从脚尖聚过头顶*6 整合动作 双手聚过头顶蹲下 立即一手抓住另一边脚尖，一手向后上方旋转 双手举过头顶站起 动作前热身 25% 动作重量*20+(力竭) 25% 动作重量*第一组少5-10次 80% 动作重量*力竭 120% 动作重量*3-5次 健身不要忘了为什么出发 PPL 推拉腿分化训练201802 推 热身 平板杠铃卧推热身 平板杠铃卧推 5*3 斜上哑铃卧推 8*3 臂屈伸 8*3 飞鸟夹胸 15*3 绳索夹胸 20*3 肱三头肌 15*3 拉 动态拉伸热身 杠铃划船热身 俯身杠铃划船6*3 引体向上6*3 坐姿绳索划船83/单手哑铃划船83/绳索单手划船8*3 窄握高位下拉8*3 Face pull 10*3 哑铃耸肩 10*3 杠片上举 10*3 曲杆弯举83/上斜哑铃弯举83 腿部 动态拉伸热身 深蹲前热身 深蹲热身 深蹲 5*3 硬拉 5*3 哈克深蹲 8*3 保加利亚分腿蹲 8*3 腿外展 15*3 3D弓步 15*3 小腿提踵 15*3 拉伸静态拉伸]]></content>
  </entry>
  <entry>
    <title><![CDATA[PythonSpeed]]></title>
    <url>%2F2017%2F07%2F28%2FPythonSpeed%2F</url>
    <content type="text"><![CDATA[Python提速的学习笔记 PythonSpeedUse the best algorithms and fastest tools Membership testing with sets and dictionaries is much faster, O(1), than searching sequences, O(n). When testing “a in b”, b should be a set or dictionary instead of a list or tuple. 1234import randomimport operatorimport numpy as npimport collections 123a = list(range(100))b = set(a)c = random.randint(0,200) 12%timeit c in a%timeit c in b 1.28 µs ± 47.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 55.5 ns ± 2.38 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) String concatenation is best done with ‘’.join(seq) which is an O(n) process. In contrast, using the ‘+’ or ‘+=’ operators can result in an O(n**2) process because new strings may be built for each intermediate step. The CPython 2.4 interpreter mitigates this issue somewhat; however, ‘’.join(seq) remains the best practice. 123y="YYYY"m="MM"d="DD" 12%timeit y+"-"+m+"-"+d%timeit "-".join((y,m,d)) 293 ns ± 8.29 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 199 ns ± 4.9 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) Many tools come in both list form and iterator form (range and xrange, map and itertools.imap, list comprehensions and generator expressions, dict.items and dict.iteritems). In general, the iterator forms are more memory friendly and more scalable. They are preferred whenever a real list is not required.(py2 only) Many core building blocks are coded in optimized C. Applications that take advantage of them can make substantial performance gains. The building blocks include all of the builtin datatypes (lists, tuples, sets, and dictionaries) and extension modules like array, itertools, and collections.deque. Likewise, the builtin functions run faster than hand-built equivalents. For example, map(operator.add, v1, v2) is faster than map(lambda x,y: x+y, v1, v2). 12v1=list(range(100))v2=list(range(120)) 12%timeit map(operator.add, v1, v2)%timeit map(lambda x,y: x+y, v1, v2) 263 ns ± 7.3 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 302 ns ± 11.8 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) Lists perform well as either fixed length arrays or variable length stacks. However, for queue applications using pop(0) or insert(0,v)), collections.deque() offers superior O(1) performance because it avoids the O(n) step of rebuilding a full list for each insertion or deletion. Custom sort ordering is best performed with Py2.4’s key= option or with the traditional decorate-sort-undecorate technique. Both approaches call the key function just once per element. In contrast, sort’s cmp= option is called many times per element during a sort. For example, sort(key=str.lower) is faster than sort(cmp=lambda a,b: cmp(a.lower(), b.lower())). Take advantage of interpreter optimizations In functions, local variables are accessed more quickly than global variables, builtins, and attribute lookups. So, it is sometimes worth localizing variable access in inner-loops. For example, the code for random.shuffle() localizes access with the line, random=self.random. That saves the shuffling loop from having to repeatedly lookup self.random. Outside of loops, the gain is minimal and rarely worth it. The previous recommendation is a generalization of the rule to factor constant expressions out of loops. Likewise, constant folding needs to be done manually. Inside loops, write “x=3” instead of “x=1+2”. Function call overhead is large compared to other instructions. Accordingly, it is sometimes worth in-lining code inside time-critical loops. List comprehensions run a bit faster than equivalent for-loops (unless you’re just going to throw away the result). Starting with Py2.3, the interpreter optimizes while 1 to just a single jump. In contrast, prior to Python 3, while True took several more steps. While the latter was preferred for clarity, time-critical code should have used the first form. Starting in Python 3, True, False, and None are reserved words, so there is no longer any performance difference here. See WhileLoop for additional details. Multiple assignment is slower than individual assignment. For example “x,y=a,b” is slower than “x=a; y=b”. However, multiple assignment is faster for variable swaps. For example, “x,y=y,x” is faster than “t=x; x=y; y=t”. 12%timeit x,y=1,2%timeit x=1; y=2 29.4 ns ± 0.51 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) 27.2 ns ± 0.745 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) Chained comparisons are faster than using the “and” operator. Write “x &lt; y &lt; z” instead of “x &lt; y and y &lt; z”. A few fast approaches should be considered hacks and reserved for only the most demanding applications. For example, “not not x” is faster than “bool(x)”. 12%timeit bool(1)%timeit not not 1 111 ns ± 5.2 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) 28.9 ns ± 1.86 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) References[1] PythonSpeed]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>speed_up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2016%2F12%2F14%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[好记性不如烂笔头。我决心做一个鲁钝的人。 我曾经想做很多事情，然而直到这几年才慢慢发现，一辈子做好一件就很不容易了。 人生的路途充满了险阻，你必须如履薄冰地小心前行。即使这样，也只能算得上是有可能安全到达目标。 在某一个周五的晚上，我在学校做算法作业到八点半。九点半匆匆赶到健身房锻炼了大概一个小时后，我突然对自己厌恶起来。 我怎能愚蠢、肥胖至此。 不知不觉我都要变成一个我厌恶的人了。我死也不要。 我想要变得更好，我需要时间，庆幸的是我还算有时间。 我想趁年轻，做点有趣的、拉风的、对自己有意义的事情来。记录不是为了炫耀曾经的成就——想想也没有什么值得炫耀的——就是为了下点笨功夫，为未来可能仍然保持愚钝的我提供些许此时的我的经验，少走一点弯路，节约一点时间。 这是我的私人博客，记录自己的生活。希望有一天回头看看的时候，这些记录值得快饮一杯酒。 A blog for my girlfriend YWT]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
</search>
